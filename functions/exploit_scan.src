exploit_scan=function(handlerType,argv)
  if not argv then return show_help("exploitscan",commands.exploitscan.args,commands.exploitscan.full_desc,commands.exploitscan.handler_types)
  if not main_session.MetaxploitLib then return print("metaxploit.so not found!")
  IP=null
  test=argv.pull
  if is_valid_ip(test) then IP=test else LIB=test
  if IP then
    if not argv then return show_help("exploitscan",commands.exploitscan.args,commands.exploitscan.full_desc,commands.exploitscan.handler_types)
    PORT=argv.pull.to_int
    if not PORT isa number then return print("Invalid port "+PORT)
    EXTRA=argv.pop
    if not EXTRA then EXTRA="."
  else
    EXTRA=argv.pop
    if not EXTRA then EXTRA="."
  end if
  if IP then
    metalib=main_session.MetaxploitLib.net_use(IP,PORT)
    if not metalib then return print("Could not connect to port: "+PORT)
    metalib=metalib.dump_lib
  else
    metalib=main_session.MetaxploitLib.load("/lib/"+LIB)
    if not metalib then return print("Could not load library: "+LIB)
  end if
  if main_session.vars.hasIndex("lib") and main_session.libList.hasIndex(main_session.vars.lib.to_int) and typeof(main_session.libList[main_session.vars.lib.to_int].lib)=="MetaxploitLib" then memory_addresses=main_session.libList[main_session.vars.lib.to_int].lib.scan(metalib) else memory_addresses=main_session.MetaxploitLib.scan(metalib)
  exploits=[]
  for memory_address in memory_addresses
    values=main_session.MetaxploitLib.scan_address(metalib,memory_address).split("Unsafe check: ")
    for unsec in values
      if unsec==values[0] then continue
      unsecValue=unsec[unsec.indexOf("<b>")+3:unsec.indexOf("</b>")]
      print("="*20)
      print(memory_address)	
      print("-"*20)
      print(unsecValue)
      print("-"*20)
      object=metalib.overflow(memory_address,unsecValue,EXTRA)
      objectType=typeof(object)
      localIP="unknown"
      if objectType=="shell" or objectType=="computer" or objectType=="file" then
        if objectType=="computer" then
          user=userCheck(object.File("/var"))
          ip=object.public_ip
          localIP=object.local_ip
          output=do_style("computer: ","green","static")+do_style(localIP,"yellow","static")
          print(output)
        end if
        if objectType=="shell" then
          user=userCheck(object.host_computer.File("/var"))
          ip=object.host_computer.public_ip
          localIP=object.host_computer.local_ip
          output=do_style("computer: ","green","static")+do_style(localIP,"yellow","static")
          print(output)
        end if
        if objectType=="file" then
          user=userCheck(object)
          router=get_router(IP)
          if router and not is_lan_ip(IP) then
            if PORT==0 or PORT==8080 then
              localIP=router.local_ip
              ip=router.public_ip
            else
              for port in router.used_ports
                if port.port_number==PORT then
                  ip=IP
                  localIP=port.get_lan_ip
                  break
                end if
              end for
            end if
          else if IP then
            localIP=IP
            ip=main_session.MetaxploitLibPublicIP
          else
            localIP=main_session.MetaxploitLibLocalIP
            ip=main_session.MetaxploitLibPublicIP
          end if
        end if
        output=do_style("objectType type: ","green","static")+do_style(objectType,"yellow","static")
        print(output)
      else if objectType=="null" then
        output=do_style("objectType type: ","green","static")+do_style(objectType,"red","static")
        print(output)
      else
        output=do_style("objectType type: ","green","static")+do_style(objectType,"blue","static")
        print(output)
        if objectType=="string" then print(object)
      end if
      if objectType!="null" and objectType!="number" and objectType!="string" then
        main_session.objectList[main_session.objectList.len]={"IP":ip,"objectType":objectType,"object":object,"localIP":localIP,"user":user}
      end if
      print("="*20)
      print
    end for
  end for
end function